Lightweight Obfuscated Datagram Protocol (LODP)
Yawning Angel <yawning@schwanenlied.me>

0. Introduction

  The Lightweight Obfuscated Datagram Protocol (LODP) is a network protocol
  designed to be a censorship resistant alternative to Datagram TLS [RFCXXXX].
  Its purpose is to keep a third part from being able to tell what protocol is in
  use based on message contents and to provide authentication and data
  integrity.

1. Motivation

  There is a large volueme of existing research and work that provides
  "reliable bulk data transfer over unreliable datagrams".  By developing a
  obfuscated datagram transport, it would be possible to leverage those
  existing designs.

  Examples for candidates for LODP encapsulation, in no particular order,
  include, SCTP-over-UDP, Reliable Data Protocol (RFC1151), UDT, and even TCP.

2. Threat Model

  The threat model for LODP is identical to the threat model of obfs3
  [OBFS3 THREAT MODEL], with added goals:

    LODP offers protection against active scanning machines that expect the
    LODP protocol.  Such machines should not be able to verify the existence
    of the LODP protocol without compromising the per-responder (server)
    shared secret used to obfuscate session initialization.

    LODP offers protection against active attackers that attempt to mount a
    man-in-the-middle attack.  The cryptographic handshake will fail, and
    such attacks will be detected.

  LODP does not protect against adversaries that are capable of measuring
  protocol entropy, or those that employ a protocol whitelist.

  Attacks on the out-of-band shared secret distribution mechanism (Eg: Tor's
  BridgeDB) are likewise outside the scope of the protocol design.  In the
  event that the public component of an endpoint becomes compromised (Eg: Due
  to Tor's BridgeDB being enumerated), the adversary is limited to denying
  service.

3. Notation, Constants and Terminology

  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
  "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
  document are to be interpreted as described in [KEYWORDS].

  All packet fields are in network byte order.

  A byte is a 8 bit octet.

  Let a | b be the concatenation of a with b.

  Let leftmost(A,n) be the leftmost n bytes of A.

  Let rightmost(A,n) be the rightmost n bytes of A.

  All random numbers used in this protocol MUST come from a cryptographically
  strong random number generator seeded from a strong entropy source.

  The Initiator is the side of a session that first initated the handshake
  (the client).

  The Responder is the side of a session that accepted the handshake initated
  by the Initiator (the server).

4. Overview

  LODP attempts to make all traffic look like random noise.  This is
  accompished by each packet sent over the wire consisting solely of the output
  of an Authenticated Encryption with Associated Data construct with a random
  nonce as the Associated Data.

  To distinguish between new sessions and existing sessions, a combination of
  examining the source address/port combination of incoming datagrams and trial
  decryption/authentication is used.

  Session initialization is obfuscated by the server maintaining a set of long
  term "Introductiory Keys" that are used to encrypt the payload and calculate
  the digest for the initialization portion of the dialog.

  During the initalization handshake, an authenticated key exchange is
  performed and ephemeral sesson keys are negotiated to provide Perfect Forward
  Secrecy.

5. Cryptographic Algorithms

  LODP uses several cryptographic algorithms as part of its protocol.

  Let H(t,x) be a cryptographic hash function with key t, and message x.

    Let HK_LEN be the length of the key in bytes.

    Let HD_LEN be the length of the digest in bytes.

  Let EXP(a,b) be curve25519(.,b,a), and g = 9. [CURVE 25519]

  Let E(t, v, x) be a stream cipher with key t, initialization vector v, and
  message x.

    Let EK_LEN be the length of the key in bytes.

    Let EV_LEN be the length of the IV in bytes.

  Let R(n) be n bytes of output from a  cryptographically strong random
  number generator seeded from a strong entropy source.

  The current implementation of LODP uses:

    H(t,x) == BLAKE2s(t,x)
    HK_LEN = 32 (256 bits)
    HD_LEN = 24 (192 bits) OR 32 (256 bits)

    The BLAKE2s algorithm [BLAKE2s] supports variable length digests and
    keys.  The shortened 192 bit digest form is used when H(t,x) is used for the
    AEAD computations, while the full output is used for all other uses of
    H(t,x).

    E(t,v,x) == XChaCha/20(t,v,x)
    EK_LEN = 32 (256 bits)
    EV_LEN = 24 (192 bits)

    The XChaCha [XCHACHA] stream cipher with 20 rounds.

5.1. LODP Key Derivation Function (LODP KDF)

  Where it is neccecary to derive keys based off a shared secret, LODP uses a
  variant of HKDF [RFC5869] adapted to use BLAKE2s' native keyed hash support
  instead of a HMAC construct.

  Step 1: Extract

    LODP-Extract(salt, IKM) -> PRK

    The output PRK is calculated as follows:

    PRK = H(salt, IKM)

  Step 2: Expand

    LODP-Expand(PRK, info, L) -> OKM

    The output OKM is calculated as follows:

    N = ceil(L/HashLen)
    T = T(1) | T(2) | T(3) | ... | T(N)
    OMK = first L octets of T

    where:
    T(0) = empty string(zero length)
    T(1) = H(PRK, T(0) | info | 0x01)
    T(2) = H(PRK, T(1) | info | 0x02)
    T(3) = H(PRK, T(2) | info | 0x03)
    ...
    T(N) = H(PRK, T(N - 1) | info | N)

5.2. LODP ntor Handshake

  LODP uses a modified version of the Tor Project's ntor handshake [NTOR] to
  perform authenticated key exchange.

  Set PROTOID == "lodp-ntor-1"

  Set ID == The Responder's globally unique identifier.

  Set X,x == The Initiator's Curve25519 key pair (X is the public component).

  Set Y,y == The Responder's Curve25519 key pair (Y is the public component).

  Set B,b == The Responder's Identity key pair (B is the public component).

  The Initiator obtains B and ID out-of-band prior to establishing a connection
  to the Responder.

  The Responder receives X in a HANDSHAKE packet and computes:

    SecretInput = EXP(X,y) | EXP(X,b) | ID | B | X | Y | PROTOID
    SharedSecret = H(PROTOID | ":key_extract", SecretInput)
    Verify = H(PROTOID | ":key_verify", SecretInput)
    AuthInput = Verify | ID | B | Y | X | PROTOID | "Responder"
    Auth = H(PROTOID | ":mac", AuthInput)

  The Initiator receives Y and Auth in a HANDSHAKE ACK packet and computes:

    SecretInput = EXP(Y,x) | EXP(B,x) | ID | B | X | Y | PROTOID
    SharedSecret = H(PROTOID | ":key_extract", SecretInput)
    Verify = H(PROTOID | ":key_verify", SecretInput)
    AuthInput = Verify | ID | B | Y | X | PROTID | "Responder"
    Auth = H(PROTOID | ":mac", AuthInput)

    The initiator then verifies that the Auth value it computed is identical
    to the one received in the HANDSHAKE ACK packet.

    Note: Both sides MUST check that none of the EXP() operations produced the
    point at infinity, and MUST abort the handshake otherwise.

5.3 The LODP SIV AEAD Construct

  LODP uses Synthetic IV [RFC5297] mode as it is currently the only encryption
  mode that does not fail catastrophically with nonce reuse.  Per the SIV
  paper the underlying constructs can be replaced in a flexible manner given
  certain constraints, the biggest one being that the function used to
  calculate the synthetic IV MUST be a strong PRF.

  Let a LODP AEAD Key be a bitstring HK_LEN + EK_LEN bytes in length.

  Let V_LEN be a predetermined random nonce length of at least 16 bytes
  (V_LEN = 16 bytres in the current implementation).

  Encryption:

    LODP-SIV-Encrypt(t, x) -> ciphertext

    The output ciphertext is calculated as follows:

    V = R(V_LEN)
    Siv = H(leftmost(t, HK_LEN), V | x)
    Ct = E(rightmost(t, EK_LEN), Siv, x)
    ciphertext = SIV | V | CT 

  Decryption:

    LODP-SIV-Decrypt(t, x) -> plaintext

    The output plaintext is calculated as follows:

    SivAd = leftmost(x, EV_LEN + V_LEN)
    Siv = leftmost(SivAd, EV_LEN)
    V = rightmost(SivAd, V_LEN)
    Pt = E(rightmost(t, EK_LEN), Siv, rightmost(t, X_LEN - (EV_LEN + V_LEN)))
    SivCheck = H(leftmost(t, HK_LEN), V | Pt)
    if is_equal(SivCheck, Siv)
      plaintext = Pt 
    else
      plaintext = FAIL

  For the purposes of LODP-SIV with BLAKE2s + XChaCha/20, HD_LEN is set to 24
  bytes to match EV_LEN.  Implementors that chose to use other constructs MUST
  pick a PRF H that produces a digest of EV_LEN bytes.

    Note: The original SIV draft uses AES-CMAC and AES-CTR for H and E
    respectively.  Given the massive difficulty associated with writing a timing
    attack resistant AES implementation, LODP choses to replace the underlying
    construct with better suited ones.

6. Cryptographic Keys

  Every peer in LODP that wishes to accept incoming connections (Responder)
  have a long term Curve25519 key pair (Identity key pair).  The Identity key
  is used by the Initiator to derive the LODP SIV key required to send data to
  the Responder while handshaking.

  Responder Identity key pair:

    Long term Curve25519 keypair used for proving host identity.  The public
    component is the shared secret used to derive the Introductory keys
    required to open a session to the Responder.

  Responder Introductory LODP SIV key:

    Long term LODP SIV key derived from the public component of the Responder
    Identity key pair via the LODP KDF.  Used to obfuscate INIT and HANDSHAKE
    packets.

    The process for deriving the Responder Introductory LODP_SIV key from a
    given public component of a Responder Identity key via the LODP KDF is as
    follows:

      Salt = "LODP-Intro-BLAKE2s"
      PRK = LODP-Extract(Salt, PublicCurve25519Key)
      RespIntroductorySIVKey = LODP-Expand(PRK, Salt, HK_LEN + EK_LEN)

  Initiator Introductory LODP SIV Key:

    Ephemeral LODP SIV key randomly generated at connection establishment time.
    Used to obfsucate INIT ACK and HANDSHAKE ACK packets.  Instead of
    transmitting the keys directly, keying material is transmitting in the
    INIT/HANDSHAKE packets and Responder uses the LODPK KDF to derive the keys.

      Salt = "LODP-Intro-BLAKE2s"
      PRK = LODP-Extract(Salt, KeyingMaterial)
      InitIntroductorySIVKey = LODP-Expand(PRK, Salt, HK_LEN + EK_LEN)

  As part of the LODP handshake, ephemeral session keys are generated and a key
  exchange is performed via the LODP ntor Handshake (See Section 5.2)
  provide Perfect Forward Secrecy.

  (Initiator/Responder) Session key exchange key pair:

    Ephemeral Curve25519 keypair(s) used to negotiate session LODP-SIV keys.
    Each endpoint has their own keypair.

  (Initiator/Responder) Session LODP SIV key(s):

    Ephemeral LODP SIV key(s) derived from the result of the handshake.  Two
    keys are generated as part of the handshake, one set for Initiator to
    Responder traffic, the other for Responder to Initiator traffic.

  The process for deriving the session LODP SIV keys from the SharedSecret output
  of the LODP ntor Handshake is as follows:

    Salt = "LODP-Session-BLAKE2s"
    OKM = LODP-Expand(SharedSecret, Salt, 2 * (HK_LEN + EK_LEN))
    InitiatorSIVKey = leftmost(OKM, HK_LEN + EK_LEN) (Initiator->Responder)
    ResponderSIVKey = rightmost(OKM, HK_LEN + EK_LEN) (Responder->Initiator)

7. Packet Format

  A LODP packet is comprised of a common header, the payload and optional
  arbitrary padding.  The payload contains either control or user data.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                              SIV                              +
                                  ...
   +                        (EV_LEN bytes)                         +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                             Nonce                             +
                                  ...
   +                         (V_LEN bytes)                         +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      Type     |     Flags     |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   \                                                               \
   /                           Packet Data                         /
   \                                                               \
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   \                                                               \
   /              Arbitrary amount of uninterpreted data           /
   \                                                               \
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

  All integer fields in a LODP packet MUST be transmitted in network byte
  order.

  SIV: EV_LEN bytes

    This field contans the synthetic IV calculated as part of
    LODP-SIV-Encrypt.

  Nonce: V_LEN bytes

    This field contains the random nonce generated as part of LODP-SIV-Encrypt.
    This nonce MUST be generated randomly and MUST NOT be reused.

  Type: 8 bits (unsigned integer)

    The type of the packet.  The values of the Type are defined as follows:

    Type Value    Type
    -----         -------------
    0            - Data (DATA)
    1            - Initiation (INIT)
    2            - Initiation Acknowledgement (INIT ACK)
    3            - Handshake (HANDSHAKE)
    4            - Handshake Acknowledgement (HANDSHAKE ACK)
    5            - Rekey (REKEY)
    6            - Rekey Acknowledgement (REKEY ACK)

  Flags: 8 bits (unsigned integer)

    Type specific flags.  Packets containing set flags that are unknown to
    the implementation MUST be dropped.

  Length: 16 bits (unsigned integer)

    Payload length including the Type, Flag and Length fields ("4" for types
    with no data).

  Packet Data: variable length

    The actual packet data.

  Arbitrary amount of uninterpreted data: variable length

    Optional padding.  Implementations MAY append random padding to each
    packet to mask the packet size signature of the upper layer protocol.
    Implementations MUST NOT interpret this data beyond what is neccecary in
    LODP-SIV-Decrypt.

  It should be unneccecary for the packet generation code to ever set the SIV
  and Nonce explicitly as the generation of those fields is handled by
  LODP-SIV-Encrypt.  That is, given a buffer containing a plaintext packet
  starting at the type field containing the full packet data including the
  optional padding (if any), LODP-SIV-Encrypt will return a buffer suitable
  for transmission.

7.1. Data (DATA)

  The following format MUST be used for Data packets.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    Type = 0   |    Reserved   |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   \                                                               \
   /                            User Data                          /
   \                                                               \
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

  Reserved: 8 bits

    Should be set to all '0's.

  Sequence Number: 32 bits

    This is the sequence number used to protect established sessions from
    replay attacks.  It is initialized to 0 when the session is established,
    and is incremented each packet that is sent (the first DATA packet sent
    over a session has a sequence number of 1).

      Note: This sequence number also applies to REKEY and REKEY ACK packets.

  User Data: variable length

    This is the user payload data.

  The session keys derived during the handshake MUST be used for the
  LODP-SIV-Encrypt of DATA packets.  DATA packets received that are
  LODP-SIV-Encrypted with Introductory keys MUST be discarded.

7.2. Initiation (INIT)

  The following format MUST be used for Initiation packets.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    Type = 1   |    Reserved   |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +           Initiator Introductory LODP-SIV Key Source          +
                                  ...
   +                           (256 bits)                          +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

  Reserved: 8 bits

    Should be set to all '0's.

  Initiator Introductory LODP-SIV Key Source: 256 bits

    The keying material used to generated the SIV key to use when sending
    the INIT ACK.

  The Responder's Introductory LODP-SIV key MUST be used for the
  LODP-SIV-Encrypt of transmitted INIT packets.  INIT packets that fail
  LODP-SIV-Decrypt on the Responder side with the Introductory LODP-SIV key
  MUST be discarded.

  Implementations MUST randomly generate the LODP-SIV key source material
  uniquely for each session.

7.3. Initiation Acknowledgement (INIT ACK)

  The following format MUST be used for Initiation Acknowledgement packets.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    Type = 2   |    Reserved   |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   \                                                               \
   /                             Cookie                            /
   \                                                               \
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

  Reserved: 8 bits

    Should be set to all '0's.

  Cookie: variable length

    An opaque cookie.  The format is up to the implementation however
    implementations SHOULD generate cookies that can be validated without
    maintaining per-connection state.

  The Initiator Introductory LODP-SIV key derived from the keying material
  received in the INIT packet that triggered a given INIT ACK MUST be used for
  the LODP-SIV-Encrypt of INIT ACK packets.

7.4. Handshake (HANDSHAKE)

  The following format MUST be used for Handshake packets.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    Type = 3   |    Reserved   |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +           Initiator Introductory LODP-SIV Key Source          +
                                  ...
   +                           (256 bits)                          +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                Initiator Curve25519 Public Key                +
                                  ...
   +                           (256 bits)                          +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   \                                                               \
   /                             Cookie                            /
   \                                                               \
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

  Reserved: 8 bits

    Should be set to all '0's.

  Initiator Introductory LODP-SIV Key Source: 256 bits

    The keying material used to generated the SIV key to use when sending
    the HANDSHAKE ACK.  It MUST be identical to the Initiator Introductory
    LODP-SIV keying material transmitted in the INIT packet.

  Initiator Curve25519 Public Key: 256 bits

    The ephemeral Curve25519 public key to use when deriving the session
    keys.

  Cookie: variable length

    The opaque cookie received in the INIT ACK, echoed exactly.

  The Responder's Introductory LODP-SIV key MUST be used for the
  LODP-SIV-Encrypt of HANDSHAKE packets.  HANDSHAKE packets that fail
  LODP-SIV-Decrypt on the responder side with the Introductory LODP-SIV key
  MUST be discarded.

7.5. Handshake Acknowledgement (HANDSHAKE ACK)

  The following format MUST be used for Handshake Acknowledgement packets.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    Type = 4   |    Reserved   |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                Responder Curve25519 Public Key                +
                                  ...
   +                           (256 bits)                          +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                Handshake Authentication Digest                +
                                  ...
   +                        (HD_LEN bytes)                         +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

  Reserved: 8 bits

    Should be set to all '0's.

  Responder Curve25519 Public Key: 256 bits

    The ephemeral Curve25519 public key to use when deriving the session
    keys.

  Handshake Authentication Digest: HD_LEN bytes

    The digest (Auth) to used when verifying the remote identity as part of
    the LODP ntor Handshake.

  The Initiator Introductory LODP-SIV key derived from the keying material
  received in the HANDSHAKE packet that triggered a given HANDSHAKE ACK MUST
  be used for the LODP-SIV-Encrypt of HANDSHAKE ACK packets.

7.6. Rekey (REKEY)

  The following format MUST be used for Rekey packets.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    Type = 5   |    Reserved   |           Length = 40         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                Initiator Curve25519 Public Key                +
                                  ...
   +                           (256 bits)                          +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

  Reserved: 8 bits

    Should be set to all '0's.

  Sequence Number: 32 bits

    This is the sequence number used to protect established sessions from
    replay attacks.  It is initialized to 0 when the session is established,
    and is incremented each packet that is sent.

      Note: This sequence number also applies to DATA and REKEY ACK packets.

  Initiator Curve25519 Public Key: 256 bits

    The Curve25519 public key to use when deriving the new session keys.

  The current session keys derived during the handshake MUST be used for the
  LODP-SIV-Encrypt of REKEY packets.  REKEY packets received that are
  LODP-SIV-Encrypted with Introductory keys MUST be discarded.

7.7. Rekey Acknowledgement (REKEY ACK)

  The following format MUST be used for Rekey Acknowledgement packets.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    Type = 6   |    Reserved   |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                Responder Curve25519 Public Key                +
                                  ...
   +                           (256 bits)                          +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                Handshake Authentication Digest                +
                                  ...
   +                        (HD_LEN bytes)                         +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

  Reserved: 8 bits

    Should be set to all '0's.

  Sequence Number: 32 bits

    This is the sequence number used to protect established sessions from
    replay attacks.  It is initialized to 0 when the session is established,
    and is incremented each packet that is sent.

    Note: This sequence number also applies to DATA and REKEY packets.

  Responder Curve25519 Public Key: 256 bits

    The Curve25519 public key to use when deriving the new session keys.

  Handshake Authentication Digest: HD_LEN bytes

    The digest (Auth) to used when verifying the remote identity as part of
    the rekeying procedure.

  The current session keys derived during the handshake MUST be used for the
  LODP-SIV-Encrypt of REKEY ACK packets.  REKEY ACK packets received that
  are LODP-SIV-Encrypted with the Introductory keys MUST be discarded.

8. Packet Processing

  When a new packet has been received implementations SHOULD process it as
  follows:

    1. Packets that are obviously malformed are silently discarded.

    2. If there is (a) existing session(s) associated with the packet's
       source address/port combination:

      a) LODP-SIV-Decrypt(SessionKey, packet)

         If this fails, the packet is processd as the potential component of a
         session handshake (Step 3).

           Note: There MAY be more than one session originating from a given
           source address/port.  It is left up to implementations if they
           allow this or not, however implementations MUST account for
           retransmitted HANDSHAKE packets in the event that HANDSHAKE ACKs
           are lost.

      b) If the packet type is INIT ACK or HANDSHAKE ACK, the packet is
         processed if the local endpoint is the Initator of the existing
         session, otherwise the packet MUST be silently discarded.

      c) If the packet type is DATA, REKEY or REKEY ACK, the sequence number is
         verified to be in the acceptable window, and the packet is processed.
         Packets that are deemed to be replays MUST be silently discarded.

      d) All other packet types MUST be silently discarded.

    3. If there is no existing session(s) associated with the packet's source
         address/port combination:

      a) LODP-SIV-Decrypt(IntroductoryKey, packet)

         If this fails (or there is no Introductory Key as in the case of a
         Initiator only endpoint) the packet MUST be silently discarded.

      b) If the packet type is INIT or HANDSHAKE the packet is processed
         (See "Session Establishment").  Otherwise the packet MUST be
         silently discarded.

9. Session Establishment

  The session establisment process and the keys used for each packet is as
  follows:

     Initiator                                 Responder
     ---------                                 ---------

     [Obtain the Responder
      Identity key]

     [Derive the Responder
      Introductory LODP-SIV key]

     [Create TCB]

     [Randomly create a Initiator
      Introductory LODP-SIV key]

     INIT (Responder Introductory   -------->
       LODP-SIV key)

                                               [Create cryptographically
                                                strong cookie]

                                               [Derive Initiator Introductory
                                                LODP-SIV key from INIT]

                                    <--------  INIT ACK (Initiator
                                                  Introductory LODP-SIV
                                                  key contained in INIT)

     HANDSHAKE (Responder           -------->
       Introductory LODP-SIV key)

                                               [Validate cookie]

                                               [Derive Initiator Introductory
                                                LODP-SIV key from HANDSHAKE]

                                               [Create TCB]

                                               [Complete ntor handshake]

                                               [Connection state ->
                                                ESTABLISHED]

                                    <--------  HANDSHAKE ACK (Initiator
                                                  Introductoru LODP-SIV key
                                                  contained in HANDSHAKE)

     [Complete ntor handshake]

     [Validate ntor digest]

     [Connection state -> ESTABLISHED]

      DATA (Initiator Session        <------->  DATA (Responder Session
        LODP-SIV key)                             LODP-SIV key)

  The Responder MUST NOT allocate any session state until it receives a valid
  HANDSHAKE packet from the Initiator.

  The Responder MUST NOT automatically retransmit HANDSHAKE ACKs.  The
  Initiator SHOULD handle the possibility of a HANDSHAKE ACK getting lost by
  retransmitting HANDSHAKE packets.  The responder MAY cache the payload of the
  HANDSHAKE ACK packet to conserve CPU, however the retransmitted HANDSHAKE ACK
  MUST be separately LODP-SIV-Encrypted to generate a new nonce.

    Note: The first DATA packet in each direction has a sequence number of 1.

10. Rekeying Procedure

  Due to the limited sequence number space, implementations MUST rotate the
  session keys periodically.  LODP implements this via the REKEY and REKEY ACK
  packets.

    Note: Rekeying is always Initiator driven.

  The rekeying process and the keys used for each packet are as follows:

     Initiator                                 Responder
     ---------                                 ---------

     REKEY (Initiator Session       -------->
        LODP-SIV key)

                                               [Validate sequence number]

                                               [Complete ntor handshake]

                                    <--------  REKEY ACK (Responder
                                                 Session LODP-SIV key from the
                                                 previous handshake)

     [Complete ntor handshake]

     [Validate ntor digest]

                                    <--------  DATA (Old Responder Session
                                                 LODP-SIV key)

      DATA (New Initiator           -------->
        Session LODP-SIV key)

      DATA (New Initiator           <------->  DATA (New Responder
        Session LODP-SIV key)                    Session LODP-SIV key)

  To account for the possibility of a REKEY ACK getting lost, the responder MUST
  not use the new Session LODP-SIV key until it receives data from the Initiator
  LODP-SIV-Encrypted with the Initiator's new Session key.  The Responder MAY
  cache the payload of the REKEY ACK packet to conserve CPU, however the
  retransmitted REKEY ACK MUST be separately LODP-SIV-Encrypted to generate a
  fresh nonce.

  To allow for proper reception of packets in flight, implementatons MAY
  interpret data LODP-SIV-Encrypted with the old session key after rekeying
  completes for a limited time window.

  Implementations MUST rekey after 2^31 packets have been sent over a given
  session in either direction.  Impementations MAY rekey more frequently.

11. Session Termination

  While there is a handshake procedure and endpoint state maintained, LODP is
  designed primarily to mimic the semantics of a connectionless datagram
  protocol (a la UDP).  Thus there is no formally established mechanism for
  connection teardown.

  Implementations MAY garbage collect idle sessions based on a timer or
  resource constraints.  Protocols using LODP as the underlying transport
  SHOULD implement their own methods for handling termination that include
  cleaning up the LODP state.

12. Security Considerations

  As UDP source addresses are trivial to forge, care must be taken when
  designing protocols that utilize it as a underlying transport.

  In order to prevent resource starvation denial of service attacks similar in
  nature to TCP SYN Floods, LODP utilizes a 4 way handshake.  This method of
  defense is similar in nature to the SCTP 4 way handshake/DTLS Cookie
  mechanism.  Implementations MUST not allocate state for incoming connections
  until a HANDSHAKE packet with a valid cookie has been received.  This
  prevents attempts to flood the connection table by spoofing INIT packets with
  forged source addresses as the echoed cookie provides proof that the
  initiating peer can receive responses.

  Due to the capability for adding random padding to mask packet size, there is
  potential for a LODP endpoint to be used as a host in an amplification
  attack by sending INIT packets with 0 padding with a spoofed source address.
  The INIT ACK packet sent in response can end up being larger than the INIT
  that triggered it.  Implementations SHOULD have suitable defenses against
  this attack, for example limiting the amount of padding in a INIT ACK (to a
  fixed value or to that of the INIT that triggered it or rate limiting the
  INIT ACK response rate.

  The protocol is protected against replay attacks by the use of a opaque
  cookie in the handshake, and the use of a sequence number in packets that are
  sent over a established session.  The algorithm for cookie generation and 
  verification presented in Appendix A does have a window in which cookies can
  be replayed however with the default values this is belived to be
  sufficiently small to where tracking spent cookies is feasable.

  The LODP SIV construct is designed to be resistant to nonce reuse/misuse, for
  example in the case that the "random number generator" gets patched by the
  distribution packager and crippled.  If the nonce is reused for a given key,
  authentication is maintained but attackers will be able to determine that
  identical data was transmited in the given LODP frames.

  A collision between SIVs for a given key will reduce the security of the bulk
  encryption component of LODP SIV to that of a n-time-pad.  With the proposed
  BLAKE2s based implementation of LODP SIV no more than 2^96 invocations of
  LODP-SIV-Encrypt should be made with a given key.  As session keys are rotated
  every 2^31 invocations in the worst case, this bound is primarily relevant to
  the long term introductory keys.  Given current and forseeable network
  transmission speeds, this bound is likely to be sufficient for the forseeable
  future.

  In the event that a collision between SIVs occurs for Responer Introductory
  keys, the recoverable plaintext via crib dragging is limited to the 4 byte
  LODP packet header as rest of payloads for the packets used as part of the
  session initialization process is high entropy random data.

13. Open Questions

  SIV mode is the most robust when random nonces are used but it's rather slow.
  It would be nice to be able to use one of the one-pass AEAD modes (AES-OCB is
  tempting).  Is there a way to prevent/mitigate the catastropic failure common
  in such modes when the nonce is reused?  For session IVs, a suitable PRP
  could be used.  What is the best way to handle nonce reuse for packets
  encrypted/authenticated with the Responder Introductory Keys?

  It would be nice to future proof the protocol by adding the capability to
  negotiate the ciphersuite at runtime, however unless multiple trial
  decryptions across all of the supported suites is acceptable in terms of
  performance for the Introductory Keys, this seems problematic to do in
  practice.

14. References

  [OBFS3 THREAT MODEL]  Kadianakis, G., "Threat model for the obfs3
                        obfuscation protocol",
                        (https://gitweb.torproject.org/pluggable-transports/
                         obfsproxy.git/blob/HEAD:/doc/obfs3/
                         obfs3-threat-model.txt)

  [KEYWORDS]     Bradner, S., "Key words for use in RFCs to Indicate
                 Requirement Levels", BCP 14, RFC 2119, March 1997.

  [CURVE 25519]  Bernstein, D. J., "A state-of-the-art Diffie-Hellman
                 function", (https://cr.yp.to/ecdh.html)

  [BLAKE2]       Aumasson, J., Neves, S., Wilcox-O'Hearn Z, and Winnerlein,
                 C., "BLAKE2: simpler, smaller, fast as MD5", June 2013.

  [XCHACHA]      Bernstein, D. J., "Extending the Salsa20 nonce",
                 (http://cr.yp.to/snuffle/xsalsa-20110204.pdf)

  [RFC5869]      Krawczyk, H. and Eronen, P., "HMAC-based Extract-and-Expand
                 Key Derivation Functions", RFC 5869, May 2010.

  [NTOR]         Matthewson, N., "Improved circuit-creation key exchange",
                 (https://gitweb.torproject.org/torspec.git/blob_plain/HEAD:
                  /proposals/216-ntor-handshake.txt)

  [RFC5297]      Kartkins, D., "Synthetic Initialization Vector (SIV)
                 Authenticated Encryption Using the Advanced Encryption
                 Standard (AES)", RFC 5297, October 2008.

15. Acknowledgements

  The author would like to thank Roger Dingledine, Elly Jones, George
  Kadianakis, Mike Perry, Nick Mathewson, Brandon Wiley, Zachary Weinberg and
  the various denizens of #tor-dev for their useful comments.

  Much of LODP's design has been inspired by the SSU protocol developed by the
  I2P project and the Stream Control Transmission Protocol.

  The ntor handshake was lifted almost verbatim from the tor specification.

  The example handshake cookie algorithm was largely inspired by that suggested
  in the DTLS specification.

Appendix A. Example Handshake Cookie Algorithm

  This is a example method of generating cookies from INIT packets, and
  validating them in HANDSHAKE packets.

  CookieKey = R(HK_LEN)

  GenerateCookie(InitPacket, addr, port) -> Cookie

  Buf = addr | port | InitPacket.InitiatorLODP-SIV-KeySrc
  Cookie = H(CookieKey, buf)

  ValidateCookie(HandshakePacket, addr, port) -> Result

  Buf = addr | port | HandshakePacket.InitiatorLODP-SIV-KeySrc
  CookieCheck = H(CookieKey, Buf)
  if is_equal(CookieCheck, HandshakePacket.Cookie)
    result = PASS
  else
    result = FAIL

  CookieKey MUST be regenerated periodically.  The algorithm does not catch
  stale cookies within the rotation period, thus the period SHOULD be
  sufficiently small.  Implementations SHOULD also prevent cookies from being
  used more than once, the amount of state required being limited by the size of
  the key regeneration period.

